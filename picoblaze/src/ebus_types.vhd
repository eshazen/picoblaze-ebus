-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl
-- 2022-03-08 10:13:19.729903

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use IEEE.math_real.all;

package ebus_types is

   -- Basic converting functions --

   procedure assign(
      variable y : out std_logic_vector;
      constant x : in std_logic_vector);

   function convert(x: std_logic_vector; t: std_logic_vector) return std_logic_vector;

   function width(x: std_logic) return natural;
   function width(x: std_logic_vector) return natural;
   function width(x: unsigned) return natural;
   function width(x: signed) return natural;
   function width(x: integer) return natural;

   function convert(x: std_logic_vector; t: signed) return signed;
   function convert(x: std_logic_vector; t: unsigned) return unsigned;
   function convert(x: std_logic_vector; t: integer) return integer;
   function convert(x: std_logic_vector; t: std_logic) return std_logic;

   function convert(x: signed; t: std_logic_vector) return std_logic_vector;
   function convert(x: unsigned; t: std_logic_vector) return std_logic_vector;
   function convert(x: integer; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic; t: std_logic_vector) return std_logic_vector;

   function zero(y: std_logic) return std_logic;
   function zero(y: std_logic_vector) return std_logic_vector;
   function zero(y: unsigned) return unsigned;
   function zero(y: signed) return signed;
   function zero(y: integer) return integer;

   -- Custom types and functions --

   constant EBUS_ADDR_WIDTH : integer := 32;

   constant EBUS_DATA_WIDTH : integer := 32;

   constant EBUS_PORT_COUNT : integer := 4;

   type ebus_out_t is record
      addr : unsigned(EBUS_ADDR_WIDTH-1 downto 0);
      data : std_logic_vector(EBUS_DATA_WIDTH-1 downto 0);
      wr : std_logic;
      rd : std_logic;
   end record ebus_out_t;
   function width(x: ebus_out_t) return natural;
   function convert(x: ebus_out_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: ebus_out_t) return ebus_out_t;

   type ebus_in_t is record
      data : std_logic_vector(EBUS_DATA_WIDTH-1 downto 0);
      ack : std_logic;
      nack : std_logic;
   end record ebus_in_t;
   function width(x: ebus_in_t) return natural;
   function convert(x: ebus_in_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: ebus_in_t) return ebus_in_t;

   type ebus_in_group_t is array(EBUS_PORT_COUNT-1 downto 0) of ebus_in_t;
   function width(x: ebus_in_group_t) return integer;
   function convert(x: ebus_in_group_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: ebus_in_group_t) return ebus_in_group_t;

end package ebus_types;

------------------------------------------------------------

package body ebus_types is

   -- Basic converting functions --

   procedure assign(
      variable y : out std_logic_vector;
      constant x : in std_logic_vector) is
      variable tmp : std_logic_vector(y'range);
   begin
      for j in 0 to y'length-1 loop
         y(y'low + j) := x(x'low + j);
      end loop;
   end procedure assign;

   function convert(x: std_logic_vector; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
   begin
      assign(y, x);
      return y;
   end function convert;
   function width(x: std_logic) return natural is
   begin
      return 1;
   end function width;
   function width(x: std_logic_vector) return natural is
   begin
      return x'length;
   end function width;
   function width(x: unsigned) return natural is
   begin
      return x'length;
   end function width;
   function width(x: signed) return natural is
   begin
      return x'length;
   end function width;
   function width(x: integer) return natural is
   begin
      return 32;
   end function width;

   function convert(x: std_logic_vector; t: signed) return signed is
      variable y: signed(t'range);
   begin
      y := signed(x);
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: unsigned) return unsigned is
      variable y: unsigned(t'range);
   begin
      y := unsigned(x);
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: integer) return integer is
      variable y: integer;
   begin
      y := to_integer(signed(x));
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: std_logic) return std_logic is
      variable y: std_logic;
   begin
      y := x(x'low);
      return y;
   end function convert;

   function convert(x: signed; t: std_logic_vector) return std_logic_vector is
   begin
      return std_logic_vector(x);
   end function convert;
   function convert(x: unsigned; t: std_logic_vector) return std_logic_vector is
   begin
      return std_logic_vector(x);
   end function convert;
   function convert(x: integer; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
   begin
      assign(y, std_logic_vector(to_signed(x, 32)));
      return y;
   end function convert;
   function convert(x: std_logic; t: std_logic_vector) return std_logic_vector is
      variable y: std_logic_vector(t'range);
   begin
      y(y'low) := x;
      return y;
   end function convert;

   function zero(y: std_logic) return std_logic is
   begin
      return '0';
   end function zero;
   function zero(y: std_logic_vector) return std_logic_vector is
   begin
      return (y'range => '0');
   end function zero;
   function zero(y: unsigned) return unsigned is
   begin
      return to_unsigned(0, y'length);
   end function zero;
   function zero(y: signed) return signed is
   begin
      return to_signed(0, y'length);
   end function zero;
   function zero(y: integer) return integer is
   begin
      return 0;
   end function zero;

   -- Custom types and functions --

   function width(x: ebus_out_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.addr);
      w := w + width(x.data);
      w := w + width(x.wr);
      w := w + width(x.rd);
      return w;
   end function width;
   function convert(x: ebus_out_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.addr);
         y(u to u+w-1) := convert(x.addr, y(u to u+w-1));
         u := u + w;
         w := width(x.data);
         y(u to u+w-1) := convert(x.data, y(u to u+w-1));
         u := u + w;
         w := width(x.wr);
         y(u to u+w-1) := convert(x.wr, y(u to u+w-1));
         u := u + w;
         w := width(x.rd);
         y(u to u+w-1) := convert(x.rd, y(u to u+w-1));
      else
         w := width(x.addr);
         y(u downto u-w+1) := convert(x.addr, y(u downto u-w+1));
         u := u - w;
         w := width(x.data);
         y(u downto u-w+1) := convert(x.data, y(u downto u-w+1));
         u := u - w;
         w := width(x.wr);
         y(u downto u-w+1) := convert(x.wr, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd);
         y(u downto u-w+1) := convert(x.rd, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: ebus_out_t) return ebus_out_t is
      variable y : ebus_out_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.addr);
         y.addr := convert(x(u to u+w-1), t.addr);
         u := u + w;
         w := width(t.data);
         y.data := convert(x(u to u+w-1), t.data);
         u := u + w;
         w := width(t.wr);
         y.wr := convert(x(u to u+w-1), t.wr);
         u := u + w;
         w := width(t.rd);
         y.rd := convert(x(u to u+w-1), t.rd);
      else
         w := width(t.addr);
         y.addr := convert(x(u downto u-w+1), t.addr);
         u := u - w;
         w := width(t.data);
         y.data := convert(x(u downto u-w+1), t.data);
         u := u - w;
         w := width(t.wr);
         y.wr := convert(x(u downto u-w+1), t.wr);
         u := u - w;
         w := width(t.rd);
         y.rd := convert(x(u downto u-w+1), t.rd);
      end if;
      return y;
   end function convert;

   function width(x: ebus_in_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.data);
      w := w + width(x.ack);
      w := w + width(x.nack);
      return w;
   end function width;
   function convert(x: ebus_in_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.data);
         y(u to u+w-1) := convert(x.data, y(u to u+w-1));
         u := u + w;
         w := width(x.ack);
         y(u to u+w-1) := convert(x.ack, y(u to u+w-1));
         u := u + w;
         w := width(x.nack);
         y(u to u+w-1) := convert(x.nack, y(u to u+w-1));
      else
         w := width(x.data);
         y(u downto u-w+1) := convert(x.data, y(u downto u-w+1));
         u := u - w;
         w := width(x.ack);
         y(u downto u-w+1) := convert(x.ack, y(u downto u-w+1));
         u := u - w;
         w := width(x.nack);
         y(u downto u-w+1) := convert(x.nack, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: ebus_in_t) return ebus_in_t is
      variable y : ebus_in_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.data);
         y.data := convert(x(u to u+w-1), t.data);
         u := u + w;
         w := width(t.ack);
         y.ack := convert(x(u to u+w-1), t.ack);
         u := u + w;
         w := width(t.nack);
         y.nack := convert(x(u to u+w-1), t.nack);
      else
         w := width(t.data);
         y.data := convert(x(u downto u-w+1), t.data);
         u := u - w;
         w := width(t.ack);
         y.ack := convert(x(u downto u-w+1), t.ack);
         u := u - w;
         w := width(t.nack);
         y.nack := convert(x(u downto u-w+1), t.nack);
      end if;
      return y;
   end function convert;
   
function width(x: ebus_in_group_t) return integer is
      variable w : integer := x'length * width(x(x'low));
   begin
      return w;
   end function width;
   function convert(x: ebus_in_group_t; t: std_logic_vector) return std_logic_vector is
   variable y : std_logic_vector(t'range);
   constant W : natural := width(x(x'low));
   variable a : integer;
   variable b : integer;
   begin
   if y'ascending then
      for i in 0 to x'length-1 loop
         a := W*i + y'low + W - 1;
         b := W*i + y'low;
         assign(y(b to a), convert(x(i+x'low), y(b to a)));
      end loop;
   else
      for i in 0 to x'length-1 loop
         a := W*i + y'low + W - 1;
         b := W*i + y'low;
         assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
      end loop;
   end if;
   return y;
   end function convert;
   function convert(x: std_logic_vector; t: ebus_in_group_t) return ebus_in_group_t is
   variable y : ebus_in_group_t;
   constant W : natural := width(y(y'low));
   variable a : integer;
   variable b : integer;
   begin
   if x'ascending then
      for i in 0 to y'length-1 loop
         a := W*i + x'low + W - 1;
         b := W*i + x'low;
         y(i+y'low) := convert(x(b to a), y(i+y'low));
      end loop;
   else
      for i in 0 to y'length-1 loop
         a := W*i + x'low + W - 1;
         b := W*i + x'low;
         y(i+y'low) := convert(x(a downto b), y(i+y'low));
      end loop;
   end if;
   return y;
   end function convert;

end package body ebus_types;
