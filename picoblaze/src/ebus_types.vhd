-- This file was auto-generated by YML2HDL toll.
-- https://gitlab.com/tcpaiva/yml2hdl

library IEEE;

use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use IEEE.math_real.all;

package ebus_types is

  procedure assign(
    variable y : out std_logic_vector;
    constant y0 : in integer;
    constant x : in std_logic_vector;
    constant x0 : in integer;
    constant l : in integer);

  function len(x: std_logic) return natural;
  function len(x: std_logic_vector) return natural;
  function len(x: unsigned) return natural;
  function len(x: signed) return natural;
  function len(x: natural) return natural;

  function structify(x: std_logic_vector; t: signed) return signed;
  function structify(x: std_logic_vector; t: unsigned) return unsigned;
  function structify(x: std_logic_vector; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: integer) return integer;
  function structify(x: std_logic_vector; t: std_logic) return std_logic;

  function vectorify(x: signed; t: std_logic_vector) return std_logic_vector;
  function vectorify(x: unsigned; t: std_logic_vector) return std_logic_vector;
  function vectorify(x: std_logic_vector; t: std_logic_vector) return std_logic_vector;
  function vectorify(x: integer; t: std_logic_vector) return std_logic_vector;
  function vectorify(x: std_logic; t: std_logic_vector) return std_logic_vector;

  function nullify(y: std_logic) return std_logic;
  function nullify(y: std_logic_vector) return std_logic_vector;
  function nullify(y: unsigned) return unsigned;
  function nullify(y: signed) return signed;
  function nullify(y: integer) return integer;

  constant EBUS_ADDR_WIDTH : integer := 32;

  constant EBUS_DATA_WIDTH : integer := 32;

  constant EBUS_PORT_COUNT : integer := 4;

  type ebus_out_t is record
    addr : unsigned(EBUS_ADDR_WIDTH-1 downto 0);
    data : std_logic_vector(EBUS_DATA_WIDTH-1 downto 0);
    wr : std_logic;
    rd : std_logic;
  end record ebus_out_t;
  function len(x: ebus_out_t) return natural;
  function vectorify(x: ebus_out_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: ebus_out_t) return ebus_out_t;
  function nullify(t: ebus_out_t) return ebus_out_t;

  type ebus_in_t is record
    data : std_logic_vector(EBUS_DATA_WIDTH-1 downto 0);
    ack : std_logic;
    nack : std_logic;
  end record ebus_in_t;
  function len(x: ebus_in_t) return natural;
  function vectorify(x: ebus_in_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: ebus_in_t) return ebus_in_t;
  function nullify(t: ebus_in_t) return ebus_in_t;

  type ebus_in_group_t is array(EBUS_PORT_COUNT-1 downto 0) of ebus_in_t;
  function len(x: ebus_in_group_t) return natural;
  function vectorify(x: ebus_in_group_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: ebus_in_group_t) return ebus_in_group_t;
  function nullify(x: ebus_in_group_t) return ebus_in_group_t;

end package ebus_types;

------------------------------------------------------------

package body ebus_types is

  procedure assign(
    variable y : out std_logic_vector;
    constant y0 : in integer;
    constant x : in std_logic_vector;
    constant x0 : in integer;
    constant l : in integer) is
    variable tmp : std_logic_vector(y'range);
  begin
    for j in 0 to l-1 loop
      tmp(j+y0) := x(j+x0);
    end loop;
    y := tmp;
  end procedure assign;
  function len(x: std_logic) return natural is
  begin
    return 1;
  end function len;
  function len(x: std_logic_vector) return natural is
  begin
    return x'length;
  end function len;
  function len(x: unsigned) return natural is
  begin
    return x'length;
  end function len;
  function len(x: signed) return natural is
  begin
    return x'length;
  end function len;
  function len(x: natural) return natural is
  begin
    return 32;
  end function len;

  function structify(x: std_logic_vector; t: signed) return signed is
    variable y: signed(t'range);
  begin
    y := signed(x);
    return y;
  end function structify;
  function structify(x: std_logic_vector; t: unsigned) return unsigned is
    variable y: unsigned(t'range);
  begin
    y := unsigned(x);
    return y;
  end function structify;
  function structify(x: std_logic_vector; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
  begin
    assign(y, t'low, x, x'low, x'length);
    return y;
  end function structify;
  function structify(x: std_logic_vector; t: integer) return integer is
    variable y: integer;
  begin
    y := to_integer(unsigned(x));
    return y;
  end function structify;
  function structify(x: std_logic_vector; t: std_logic) return std_logic is
    variable y: std_logic;
  begin
    y := x(x'low);
    return y;
  end function structify;

  function vectorify(x: signed; t: std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(x);
  end function vectorify;
  function vectorify(x: unsigned; t: std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(x);
  end function vectorify;
  function vectorify(x: std_logic_vector; t: std_logic_vector) return std_logic_vector is
  begin
    return x;
  end function vectorify;
  function vectorify(x: integer; t: std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(to_unsigned(x, 32));
  end function vectorify;
  function vectorify(x: std_logic; t: std_logic_vector) return std_logic_vector is
    variable y: std_logic_vector(t'range);
  begin
    y(y'low) := x;
    return y;
  end function vectorify;

  function nullify(y: std_logic) return std_logic is
  begin
      return '0';
  end function nullify;
  function nullify(y: std_logic_vector) return std_logic_vector is
  begin
      return (y'range => '0');
  end function nullify;
  function nullify(y: unsigned) return unsigned is
  begin
    return to_unsigned(0, y'length);
  end function nullify;
  function nullify(y: signed) return signed is
  begin
    return to_signed(0, y'length);
  end function nullify;
  function nullify(y: integer) return integer is
  begin
    return 0;
  end function nullify;

  function len(x: ebus_out_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.addr);
    l := l + len(x.data);
    l := l + len(x.wr);
    l := l + len(x.rd);
    return l;
  end function len;
  function vectorify(x: ebus_out_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      y(left to left+len(x.addr)-1) := vectorify(x.addr, y(left to left+len(x.addr)-1));
      left := left + len(x.addr);
      y(left to left+len(x.data)-1) := vectorify(x.data, y(left to left+len(x.data)-1));
      left := left + len(x.data);
      y(left to left+len(x.wr)-1) := vectorify(x.wr, y(left to left+len(x.wr)-1));
      left := left + len(x.wr);
      y(left to left+len(x.rd)-1) := vectorify(x.rd, y(left to left+len(x.rd)-1));
    else
      y(left downto left-len(x.addr)+1) := vectorify(x.addr, y(left downto left-len(x.addr)+1));
      left := left - len(x.addr);
      y(left downto left-len(x.data)+1) := vectorify(x.data, y(left downto left-len(x.data)+1));
      left := left - len(x.data);
      y(left downto left-len(x.wr)+1) := vectorify(x.wr, y(left downto left-len(x.wr)+1));
      left := left - len(x.wr);
      y(left downto left-len(x.rd)+1) := vectorify(x.rd, y(left downto left-len(x.rd)+1));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: ebus_out_t) return ebus_out_t is
    variable y: ebus_out_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.addr := structify(x(left to left+len(y.addr)-1), y.addr);
      left := left + len(y.addr);
      y.data := structify(x(left to left+len(y.data)-1), y.data);
      left := left + len(y.data);
      y.wr := structify(x(left to left+len(y.wr)-1), y.wr);
      left := left + len(y.wr);
      y.rd := structify(x(left to left+len(y.rd)-1), y.rd);
    else
      y.addr := structify(x(left downto left-len(y.addr)+1), y.addr);
      left := left - len(y.addr);
      y.data := structify(x(left downto left-len(y.data)+1), y.data);
      left := left - len(y.data);
      y.wr := structify(x(left downto left-len(y.wr)+1), y.wr);
      left := left - len(y.wr);
      y.rd := structify(x(left downto left-len(y.rd)+1), y.rd);
    end if;
    return y;
  end function structify;
  function nullify(t: ebus_out_t) return ebus_out_t is
  variable y: ebus_out_t;
  begin
    y.addr := nullify(t.addr);
    y.data := nullify(t.data);
    y.wr := nullify(t.wr);
    y.rd := nullify(t.rd);
    return y;
  end function nullify;

  function len(x: ebus_in_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.data);
    l := l + len(x.ack);
    l := l + len(x.nack);
    return l;
  end function len;
  function vectorify(x: ebus_in_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      y(left to left+len(x.data)-1) := vectorify(x.data, y(left to left+len(x.data)-1));
      left := left + len(x.data);
      y(left to left+len(x.ack)-1) := vectorify(x.ack, y(left to left+len(x.ack)-1));
      left := left + len(x.ack);
      y(left to left+len(x.nack)-1) := vectorify(x.nack, y(left to left+len(x.nack)-1));
    else
      y(left downto left-len(x.data)+1) := vectorify(x.data, y(left downto left-len(x.data)+1));
      left := left - len(x.data);
      y(left downto left-len(x.ack)+1) := vectorify(x.ack, y(left downto left-len(x.ack)+1));
      left := left - len(x.ack);
      y(left downto left-len(x.nack)+1) := vectorify(x.nack, y(left downto left-len(x.nack)+1));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: ebus_in_t) return ebus_in_t is
    variable y: ebus_in_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data := structify(x(left to left+len(y.data)-1), y.data);
      left := left + len(y.data);
      y.ack := structify(x(left to left+len(y.ack)-1), y.ack);
      left := left + len(y.ack);
      y.nack := structify(x(left to left+len(y.nack)-1), y.nack);
    else
      y.data := structify(x(left downto left-len(y.data)+1), y.data);
      left := left - len(y.data);
      y.ack := structify(x(left downto left-len(y.ack)+1), y.ack);
      left := left - len(y.ack);
      y.nack := structify(x(left downto left-len(y.nack)+1), y.nack);
    end if;
    return y;
  end function structify;
  function nullify(t: ebus_in_t) return ebus_in_t is
  variable y: ebus_in_t;
  begin
    y.data := nullify(t.data);
    y.ack := nullify(t.ack);
    y.nack := nullify(t.nack);
    return y;
  end function nullify;

  function len(x: ebus_in_group_t) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function vectorify(x: ebus_in_group_t; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i+l-1+x'low;
        b := l*i+x'low;
        y(b to a) := vectorify(x(i), y(b to a));
      end loop;
    else
      for i in x'range loop
        a := l*i+l-1+x'low;
        b := l*i+x'low;
        y(a downto b) := vectorify(x(i), y(a downto b));
      end loop;
    end if;
    return y;
  end function vectorify;
  function structify(x: std_logic_vector; t: ebus_in_group_t) return ebus_in_group_t is
    variable y : ebus_in_group_t;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i+l-1+x'low;
        b := l*i+x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i+l-1+x'low;
        b := l*i+x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function nullify(x: ebus_in_group_t) return ebus_in_group_t is
    variable y : ebus_in_group_t;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;

end package body ebus_types;
